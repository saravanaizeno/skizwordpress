<?php
/*
Plugin Name: WP2Cloud - WordPress to Cloud
Plugin URI: http://www.oblaksoft.com/documentation/yapixx
Description: Uses <a href="http://www.oblaksoft.com/documentation">ClouSE</a> to store media content in the cloud storage.  Now any WordPress website can effortlessly store media in the cloud and rely on the power of cloud storage to make serving the media highly scalable while storing it extremely durable.
Author: OblakSoft
Version: 1.3.9
Author URI: http://www.oblaksoft.com
License: GPLv2
*/

/*
Copyright (c) 2012-2013, OblakSoft LLC.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/


//--------
// Include headers requred for crop_and_upload_bp_avatar.
if(defined('ABSPATH')) {
    require_once(ABSPATH . '/wp-admin/includes/image.php');
    require_once(ABSPATH . '/wp-admin/includes/file.php');
}

//--------
// Load WordPress bootstrap, if this file is referred directly.
// This requires wp2cloud.php to be located in the
// [ROOT]/wp-content/plugins/wp2cloud-wordpress-to-cloud/ directory.
require_once(dirname(dirname(dirname(dirname(__FILE__)))) . '/wp-load.php');
require_once('setoptions.php');

function wp2cloud_plugin_dir_url() {
    global $current_blog;

    $url = @parse_url(plugin_dir_url(__FILE__), PHP_URL_PATH);

    if (!empty($current_blog) && strpos($url, $current_blog->path) !== 0) {
        $url = rtrim($current_blog->path, '/') . '/' . ltrim($url, '/');
    }

    return $url;
}

define('WP2CLOUD_DIR_URL', wp2cloud_plugin_dir_url());

$clouSE_upload_id = array();

$wp2cloud_plugin = new Wp2CloudPlugin();

//--------
// This plugin implements the capability to upload pictures (and other media)
// to the cloud using OblackSoft's ClouSE -- the Cloud Storage Engine
// for MySQL.
// When a new media file is uploaded it will be stored in the cloud along
// with all the intermediate files generated by WordPress (thumbnails).
class Wp2CloudPlugin {
    var $media_db;

    var $ClouSE_table_name;
    var $bp_avatars_table;

    var $last_wbid;
    var $last_wb_url;

    var $bp_fetch_urls;
    var $bp_uploading_avatar;

    function Wp2CloudPlugin() {
        global $wpdb;

        $this->last_wbid = null;
        $this->last_wb_url = null;

        $this->bp_fetch_urls = null;
        $this->bp_uploading_avatar = false;

        //--------
        // Populate the database.
        if(defined('MEDIA_DB_NAME') && defined('MEDIA_DB_USER') &&
           defined('MEDIA_DB_PASSWORD') && defined('MEDIA_DB_HOST')) {
            //--------
            // Connect to a different media DB.
            $this->media_db = new wpdb(MEDIA_DB_USER, MEDIA_DB_PASSWORD, MEDIA_DB_NAME, MEDIA_DB_HOST);
        } else {
            $this->media_db = $wpdb;
        }

        //--------
        // Populate the table names.
        $this->ClouSE_table_name = $wpdb->prefix . "cloud_media_content";
        $this->bp_avatars_table = $wpdb->prefix . "bp_cloud_avatars";

        //--------
        // Registration/de-registration callbacks.
        register_activation_hook( __FILE__, array(&$this, 'activate') );
        register_deactivation_hook( __FILE__, array(&$this, 'deactivate') );

        add_action('plugins_loaded', array(&$this, 'addhooks'));

        //--------
        // Start output buffering to translate weblob_id-based URLs to direct
        // URLS for frontend pages.
        if(!defined('WP_ADMIN'))
            ob_start(array(&$this, 'ob_callback'));
    }

    function ensure_cloud_table($die_on_error=true) {
        //--------
        // The plugin can only work if the current MySQL setup supports
        // ClouSE storage engine.
        try
        {
            //--------
            // Create the table that contains a WEBLOB field to store pictures
            // (and other media) in the cloud.
            //
            // A WEBLOB field is expressed via two MySQL fields:
            //   value$wblob_info blob -- control commands on input / URL on output
            //   value$wblob  longblob -- BLOB to store the media content
            $this->query('set sql_mode="NO_ENGINE_SUBSTITUTION"');
            $this->query('create table if not exists # (id bigint auto_increment, name varchar(128) collate utf8_bin, value$wblob_info blob, value$wblob longblob, primary key(id,name)) engine = "ClouSE"',
                array($this->ClouSE_table_name));
        }
        catch(Exception $e)
        {
            if($die_on_error)
            {
                wp_die("Cannot create <b>" . $this->ClouSE_table_name ."</b> table -- ".$e->getMessage().
                   "  WP2Cloud requires the Cloud Storage Engine for MySQL (<a href='http://www.oblaksoft.com/documentation/getting-started-with-clouse/'>ClouSE</a>)".
                   " to be installed and configured on the MySQL server.  As an example of properly configured ClouSE and WP2Cloud you can use".
                   " <a href='http://www.oblaksoft.com/downloads/'>WordPress on S3 Amazon Machine Image (AMI)</a>.");
            }
        }
    }

    function activate() {
        $this->ensure_cloud_table();
     }

    function deactivate() {

    }

    //--------
    // Executes a "Safe" query
    function query_safe($db, $sql_query, $params=false)
    {
        if ($params)
        {
            foreach ($params as &$v) { $v = mysql_real_escape_string($v); }    // Escape the params
                # str_replace - replacing # -> %s. %s is ugly in raw sql query
                # vsprintf - replacing all %s to parameters
                $sql_query = vsprintf( str_replace("#", "%s", $sql_query), $params );
        }

        $sql_result = $db->get_results($sql_query, ARRAY_N);

        return ($sql_result);
    }

    //--------
    // Executes a query
    function query($sqlQuery, $params = 0)
    {
        $this->media_db->last_error = '';
        $results = $this->query_safe($this->media_db, $sqlQuery, $params);

        if ($this->media_db->last_error)
        {
            throw new Exception('MySQL error: ' . $this->media_db->last_error);
        }

        return $results;
    }

    //--------
    // Adds hooks to the actions this plugin need.
    function addhooks() {
        add_filter('wp_handle_upload', array(&$this, 'wp_handle_upload'), 9, 2);
        add_filter('plugin_row_meta', array(&$this, 'add_plugin_meta'), 10, 2);

        add_filter('wp_update_attachment_metadata', array(&$this, 'wp_update_attachment_metadata_add_exif'), 9, 2);
        add_filter('wp_update_attachment_metadata', array(&$this, 'wp_update_attachment_metadata'), 9, 2);
        add_filter('wp_delete_file', array(&$this, 'wp_delete_file'), 9, 1);
        add_filter('wp_save_image_file', array(&$this, 'wp_save_image_file'), 9, 5);
        add_filter('wp_save_image_editor_file', array(&$this, 'wp_save_image_file'), 9, 5);

        add_filter('wp_get_attachment_thumb_url', array(&$this, 'wp_get_attachment_url'), 9, 2);
        add_filter('wp_get_attachment_url', array(&$this, 'wp_get_attachment_url'), 9, 2);
        add_filter('load_image_to_edit_attachmenturl', array(&$this, 'load_image_to_edit_attachmenturl'), 9, 3);

        add_filter('bp_core_avatar_folder_url', array(&$this, 'bp_core_avatar_folder_url'), 9, 4);
        add_filter('bp_core_avatar_folder_dir', array(&$this, 'bp_core_avatar_folder_dir'), 9, 4);
        add_filter('bp_core_fetch_avatar', array(&$this, 'bp_core_fetch_avatar'), 9, 9);
        add_filter('bp_core_fetch_avatar_url', array(&$this, 'bp_core_fetch_avatar_url'), 9, 1);

        add_filter('bp_core_pre_avatar_handle_upload', array(&$this, 'bp_core_pre_avatar_handle_upload'), 9, 3);
        add_filter('bp_core_pre_avatar_handle_crop', array(&$this, 'bp_core_pre_avatar_handle_crop'), 9, 2);
        add_filter('bp_core_delete_existing_avatar', array(&$this, 'bp_core_delete_existing_avatar'), 9, 1);

        add_filter('bp_activity_content_before_save', array(&$this, 'bp_activity_content_before_save'), 9, 2);

        add_filter('bp_album_get_picture_original_url', array(&$this, 'bp_album_get_picture_url'),9, 1);
        add_filter('bp_album_get_picture_middle_url', array(&$this, 'bp_album_get_picture_url'),9, 1);
        add_filter('bp_album_get_picture_thumb_url', array(&$this, 'bp_album_get_picture_url'),9, 1);
        add_action('bp_album_data_after_save', array(&$this, 'bp_album_data_after_save'),9, 1);
        add_action('bp_album_delete_picture', array(&$this, 'bp_album_delete_picture'),9, 1);

        add_filter('wpseo_xml_sitemap_img_src', array(&$this, 'wpseo_xml_sitemap_img_src'),9, 2);

        add_filter('wp2cloud_upload_file', array(&$this, 'wp2cloud_upload_file'), 9, 1);
        add_filter('wp2cloud_delete_file', array(&$this, 'wp_delete_file'), 9, 1);
        add_action('wp2cloud_download_file', array(&$this, 'wp2cloud_download_file'), 9, 1);
        add_filter('wp2cloud_get_file_url', array(&$this, 'wp2cloud_get_file_url'), 9, 1);

        add_filter('image_downsize', array(&$this, 'image_downsize'), 9, 3);

        if(current_user_can('edit_posts') || current_user_can('edit_pages'))
        {
            if(get_user_option('rich_editing') == 'true')
            {
                add_filter("mce_external_plugins", array(&$this, 'add_custom_tinymce_plugin_clouse'));
            }
        }

        add_action('admin_menu', array(&$this, 'settings'));

        if(current_user_can('install_plugins'))
            add_action('admin_notices', array(&$this,'admin_notices'));

        //--------
        // Add our shortcode handler.
        add_shortcode( 'WP2CLOUD', array(&$this, 'wp2cloud_shortcode_handler'));

    }

    //--------
    // Plugin settings.
    function settings() {
        add_options_page('WordPress to Cloud', 'WordPress to Cloud', 'manage_options', dirname(__FILE__) . '/setoptions.php', 'wp2cloud_settings');
    }

    //--------
    // Add custom plugin for handling shortcodes in the visual editor.
    // Plugin versions prior 1.1.4 used WP2CLOUD shortcodes for for
    // weblob ids.  We continue handling those, even though now we
    // use weblob_id-based URLs.
    function add_custom_tinymce_plugin_clouse($plugin_array)
    {
        $plugin_array['wp2cloud'] = WP2CLOUD_DIR_URL . 'wp2cloud-mce.php';
        return $plugin_array;
    }

    //--------
    // Plugin errors and warnings in the admin area.
    function admin_notices()
    {
        $options = get_option('wp2cloud');

        if(empty($options) || $options['ignore_nocloud'] != '1')
        {
            //--------
            // Check that all WordPress tables are in the cloud and complain
            // if they are not.

            global $wpdb;

            try
            {
                $results = $this->query_safe($wpdb, 'select sql_calc_found_rows table_name
                    from information_schema.tables
                    where table_schema="#" and table_name like "#%%" and engine<>"ClouSE"
                    limit 3', array($wpdb->dbname, $wpdb->base_prefix));

                $found_rows = $this->query_safe($wpdb, 'select found_rows();');
            }
            catch(Exception $e)
            {
                return;  // oh well
            }

            if(!count($results))
                return;

            //--------
            // We've got some tables that are not using ClouSE.  Warn the
            // user about those.
            echo '<div class="error"><p>';
            $next = false;

            foreach($results as $r)
            {
                if($next)
                    echo ', ';
                else
                    $next = true;

                echo '<strong>' . htmlspecialchars($r[0]) . '</strong>';
            }

            $extra = intval($found_rows[0][0]) - count($results);

            if($extra)
                echo ", and $extra more";

            if(count($results) == 1)
                echo ' table is';
            else
                echo ' tables are';

            echo ' not managed by the Cloud Storage Engine and not
                protected by the cloud storage.';
            echo '</p></div>';

        }
    }

    //--------
    // This is the shortcode handler for the WP2CLOUD code.
    // Plugin versions prior 1.1.4 used WP2CLOUD shortcodes for for
    // weblob ids.  We continue handling those, even though now we
    // use weblob_id-based URLs.
    function wp2cloud_shortcode_handler( $atts )
    {
        extract( shortcode_atts( array(
                'weblob_id' => 0,
        ), $atts ) );

        return $this->get_url_from_weblob_id($weblob_id);
    }

    //--------
    // Adds links on the plugin page
    function add_plugin_meta($links, $file) {
        if ($file == plugin_basename(__FILE__))
            $links[] = '<a href="http://wordpress.org/extend/plugins/wp2cloud-wordpress-to-cloud/">Rate this plugin</a>';
            $links[] = '<a href="http://www.facebook.com/pages/OblakSoft-LLC/324769304220011">Facebook</a>';
            $links[] = '<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=JMUHXKMNCQ75N">Donate</a>';
        return $links;
    }

    //--------
    // Parse WEBLOB id (either file path or weblob_id)
    function parse_weblob_id($val)
    {
        //--------
        // Format:
        //   File path: [ROOT]/uploads/$wblob/id/name
        //   weblob_id: id/name
        //
        // We force id to be numeric.

        return array('id' => intval(basename(dirname($val))), 'name' => basename($val));
    }

    //--------
    // Format WEBLOB id into a string
    function fmt_weblob_id($id, $name)
    {
        //--------
        // Format: id/name
        return $id . '/' . $name;
    }

    //--------
    // Get WEBLOB id from path
    function weblob_id_from_path($path)
    {
        $wbid = $this->parse_weblob_id($path);
        return $this->fmt_weblob_id($wbid['id'], $wbid['name']);
    }

    //--------
    // Generate new WEBLOB id and update the file name.
    function gen_weblob_id($data)
    {
        //--------
        // Upload media files to the cloud.
        if (file_exists($data['file'])) {

            //--------
            // Each weblob_id is represented by an {id, name} pair.  For
            // each uploaded file a new id is generated to prevent name
            // collisions for user-uploaded files.  WordPress then may
            // generate new files (e.g. for image resize and etc.) that
            // would result into new names.  Logically, you can think of
            // id being a directory (and that's how it's represented on
            // the file system) that holds each uploaded file and all
            // its transformations made by WordPress.
            //
            // The name-based weblob_id is chosen to satisfy WordPress
            // assumptions it sometimes makes about URLs, e.g. it may
            // change the name of foo.jpg to cropped-foo.jpg and expect
            // that the URL can be transformed the same way (which would
            // be not the case if we generated an arbirary id).
            //
            // The name per se doesn't matter much, we try to preserve the
            // orignal, but sanitize the name to be ASCII to avoid
            // issues with encodings (this is an artifact of having had the
            // name column previously collated as latin_bin and we may remove
            // the code or make it optional).
            $wbname = preg_replace('/[^\x20-\x7E]/','~', wp_basename($data['file']));

            $retry = true;

            while(true) {
                try {
                    $this->query('insert into # (id, name, value$wblob_info, value$wblob) values (0, "#", NULL, NULL)',
                        array($this->ClouSE_table_name, $wbname));
                }
                catch(Exception $e) {
                    // If the plugin is network-activated, the table may not
                    // exist in this site's database.  Try to create it.

                    if ($retry) {
                        $retry = false;
                        $this->ensure_cloud_table(false);
                        continue;
                    }

                    throw $e;
                }

                break;
            }

            $result = $this->query('select last_insert_id()');
            $id = $result[0][0];

            $uploads = wp_upload_dir();

            if($uploads['error'] !== false)
                return $uploads;

            $data['file'] = $uploads['basedir'] . '/$wblob/' . $this->fmt_weblob_id($id, $wbname);
        }

        return $data;
    }

    //--------
    // Handle uploads through the default WordPress upload handler (pre-attachment).
    function wp_handle_upload($data, $override)
    {
        global $clouSE_upload_id;

        if($this->bp_uploading_avatar)
        {
            //--------
            // BuddyPress doesn't use media library, so loading media
            // to the cloud leads to unreferenced media files.  We detect
            // BuddyPress uploads and avoid that.
            $this->bp_uploading_avatar = false;
            return $data;
        }

        //--------
        // Generate new id and move the file to the weblob_id-based
        // directory to establish 1-to-1 correspondence between file
        // names and weblob_ids.
        $old_file = $data['file'];
        $data = $this->gen_weblob_id($data);

        if(isset($data['error']))
            return $data;

        wp_mkdir_p(dirname($data['file']));

        if(rename($old_file, $data['file']) === false)
        {
            $data['error'] = 'Failed to rename to '.$data['file'];
            return $data;
        }

        //--------
        // Upload media files to the cloud.
        if (file_exists($data['file'])) {
            //--------
            // Upload the main file to the cloud using WEBLOBs.
            try
            {
                $this->query('start transaction');
                $id_main = $this->upload_image_to_cloud($data['file'], $data['file']);
                $this->query("commit");
            }
            catch(Exception $e)
            {
                $this->query("rollback");
                throw $e;
            }

            $data['url'] = WP2CLOUD_DIR_URL.'wp2cloud.php?weblob_id=' . $id_main;
            $clouSE_upload_id[$data['file']] = $id_main;
        }

        return $data;
    }

    //--------
    // Handle uploads through the default WordPress upload handler.
    function wp_update_attachment_metadata_add_exif($data, $postID) {

        $data['file'] = get_attached_file($postID, true);

        try
        {
            //--------
            // Read the exif data and add mediatags.
            if (file_exists($data['file'])) {
                $this->process_file($postID, $data['file']);
            }
        }
        catch(Exception $e)
        {
            //-------
            // It is "OK" if we couldn't get the file metadata...
        }

        return $data;
    }

    //--------
    // This is the main handler for attachment processing.
    // When this function is called the intermediate files are already created.
    function wp_update_attachment_metadata($data, $postID) {
        global $clouSE_upload_id;

        $data['file'] = get_attached_file($postID, true);
        $main_file = $data['file'];

        if (strpos($data['file'], '$wblob') === false)
        {
            //--------
            // Some plugins bypass the wp_handle_upload filter, so we
            // generate new WEBLOB id and upload the file here.
            // The filename is changed too.
            $data = $this->gen_weblob_id($data);

            if($data['error'])
                return $data;

            update_attached_file($postID, $data['file']);
        }

        //--------
        // Upload media files to the cloud.
        // All related files are going to be atomically uploaded as one
        // transaction.
        try
        {
            $this->query('start transaction');

            //--------
            // Upload the main file to the cloud using WEBLOBs.
            if(!isset($clouSE_upload_id[$data['file']]))
            {
                $this->upload_image_to_cloud($main_file, $data['file']);
            }

            if (isset($data['thumb'])) {
                $thumbpath = str_replace(wp_basename( $main_file ), $data['thumb'], $main_file);
                $thumbid = str_replace(wp_basename( $data['file'] ), $data['thumb'], $data['file']);

                //--------
                // Upload the thumbnail.
                $this->upload_image_to_cloud($thumbpath, $thumbid);
            }

            if (count($data['sizes'])) {
                foreach ($data['sizes'] as $altName => $altSize) {
                    $altPath = str_replace(wp_basename( $main_file ), $altSize['file'], $main_file);
                    $altId = str_replace(wp_basename( $data['file'] ), $altSize['file'], $data['file']);

                    //--------
                    // Upload the different file sizes generated.
                    $this->upload_image_to_cloud($altPath, $altId);
                }
            }

            //--------
            // Everything is alright, commit it!
            $this->query("commit");
        }
        catch(Exception $e)
        {
            //--------
            // Rollback the whole transaction.
            $this->query("rollback");

            throw $e;
        }

        //--------
        // Remove the local files no matter what so the user will realize
        // something went wrong right away.
        $this->delete_all_local_files($data, $main_file);

        return $data;
    }

    function delete_all_local_files($data, $main_file) {
        if (file_exists($main_file)) {
            @ unlink( path_join($uploadpath['basedir'], $main_file) );
        }

        if (isset($data['thumb'])) {
            $thumbfile = str_replace(wp_basename( $main_file ), $data['thumb'], $main_file);
            @ unlink( path_join($uploadpath['basedir'], $thumbfile) );
        }

        //-------
        // remove intermediate and backup images if there are any
        if (count($data['sizes'])) {
            foreach ($data['sizes'] as $altName => $altSize) {
                $altPath = str_replace(wp_basename( $main_file ), $altSize['file'], $main_file);
                @ unlink( path_join($uploadpath['basedir'], $altPath) );
            }
        }
    }

    //--------
    // Delete WEBLOB by file name.
    function wp_delete_file($file) {
        //-------
        // Only deal with files uploaded by us.
        if (strpos($file, '$wblob') === false)
            return $file;

        try {
            $wbid = $this->parse_weblob_id($file);
            $this->query('delete from # where id=# and name="#"',
                array($this->ClouSE_table_name, $wbid['id'], $wbid['name']));
        }
        catch(Exception $e)
        {
            // Oh, well.
        }

        return $file;
    }

    //--------
    // Create a directory for the new image file.
    function wp_save_image_file($saved, $filename, $image, $mime_type, $post_id) {
        wp_mkdir_p(dirname($filename));
        return $saved;
    }

    //--------
    // Gets the attachment URL for the media content.
    function wp_get_attachment_url($url, $postID) {
        $weblob_id = $this->weblob_id_from_path($url);
        $weblob_url = $this->get_url_from_weblob_id($weblob_id);

        if (!$weblob_url)
            return $url;

        if (strpos($_SERVER['PHP_SELF'], '/wp-admin/') === false)
            return $weblob_url;

        // When working from admin console, we generate more conservative
        // weblob_id-based URL.  They require an extra redirect to get to the
        // cloud storage, but they are more robust.

        return WP2CLOUD_DIR_URL . 'wp2cloud.php?weblob_id=' . $weblob_id;
    }

    //--------
    // Translate path-based URL into weblob_id-based URL.
    function xlate_path_url($matches)
    {
        // The $matches array contains the following:
        // $matches[0] - the orginal URL, e.g. [path]/$wblob/42/foo
        // $matches[1] - the weblob_id, e.g. 42/foo

        $weblob_url = $this->get_url_from_weblob_id($matches[1]);
        return $weblob_url ? '"' . WP2CLOUD_DIR_URL . 'wp2cloud.php?weblob_id=' . $matches[1] .'"' : $matches[0];
    }

    //--------
    // Substibute file-based URLs to weblob-based URLs.
    function bp_activity_content_before_save($content, $bpa) {
        return preg_replace_callback( '#"[^"]+/\$wblob/([^"]+)"#', array(&$this, 'xlate_path_url'), $content);
    }

    //--------
    // Gets the URL for the BP album picture.
    function bp_album_get_picture_url($url) {
        $weblob_id = $this->weblob_id_from_path($url);
        $weblob_url = $this->get_url_from_weblob_id($weblob_id);
        return $weblob_url ? $weblob_url : $url;
    }

    //--------
    // Uploads BP album picture file to cloud storage.
    function bp_album_upload_file($file) {
        global $clouSE_upload_id;

        if (strpos($file, '$wblob') === false)
            return;  // don't mess with files not uploaded by us.

        if (isset($clouSE_upload_id[$file]))
            return;  // already uploaded it in wp_handle_upload

        $this->upload_image_to_cloud($file, $file);
    }

    //--------
    // Deletes BP album picture file from local storage.
    function bp_album_delete_local_file($file) {
        if (strpos($file, '$wblob') !== false)
            @unlink($file);
    }

    //--------
    // Uploads BP album picture to cloud.
    function bp_album_data_after_save($pic) {
        // $pic is a structure that describes a BP album picture.

        try
        {
            $this->query('start transaction');
            $this->bp_album_upload_file($pic->pic_org_path);
            $this->bp_album_upload_file($pic->pic_mid_path);
            $this->bp_album_upload_file($pic->pic_thumb_path);
            $this->query('commit');
        }
        catch(Exception $e)
        {
            //--------
            // Rollback the whole transaction.
            $this->query('rollback');

            throw $e;
        }

        $this->bp_album_delete_local_file($pic->pic_org_path);
        $this->bp_album_delete_local_file($pic->pic_mid_path);
        $this->bp_album_delete_local_file($pic->pic_thumb_path);
    }

    //--------
    // Deletes BP album picture from cloud.
    function bp_album_delete_picture($pic) {
        // $pic is a structure that describes a BP album picture.

        $this->wp_delete_file($pic->pic_org_path);
        $this->wp_delete_file($pic->pic_mid_path);
        $this->wp_delete_file($pic->pic_thumb_path);
    }

    //--------
    // Gets the direct cloud storage URL for the media content.
    function wbid_url_to_cloud($url)
    {

        if (preg_match("#.*/wp2cloud.php\?weblob_id=(.*)$#i", $url, $matches) === 1)
        {
            $weblob_url = $this->get_url_from_weblob_id($matches[1]);
            return $weblob_url ? $weblob_url : $url;
        }

        return $url;
    }

    //--------
    // Translate URLs in SEO XML sitemap images.
    function wpseo_xml_sitemap_img_src($src, $p)
    {
        return $this->wbid_url_to_cloud($src);
    }

    //--------
    // Upload file to the cloud.
    function wp2cloud_upload_file($file)
    {
        $data = $this->wp_handle_upload(array('file' => $file), false);

        if (isset($data['error']) || !isset($data['file']))
            return $file;

        @unlink($data['file']);

        return $data['file'];
    }

    //--------
    // Download cloud file into local file.
    // The local file is supposed to be used only as temporary.
    function wp2cloud_download_file($file) {
        $weblob_url = $this->wp2cloud_get_file_url($file);

        if ($weblob_url != $file) {
            wp_mkdir_p(dirname($file));
            copy($weblob_url, $file);
        }
    }

    //--------
    // Get file URL by name.
    function wp2cloud_get_file_url($file)
    {
        //-------
        // Only deal with files uploaded by us.
        if (strpos($file, '$wblob') === false)
            return $file;

        $weblob_id = $this->weblob_id_from_path($file);
        $weblob_url = $this->get_url_from_weblob_id($weblob_id);

        if ($weblob_url)
            return $weblob_url;

        return $file;
    }

    //--------
    // Translate weblob_id-based URL into direct cloud storage URL.
    function xlate_wbid_url($matches)
    {
        // The $matches array contains the following:
        // $matches[0] - the orginal URL, e.g. [path]/wp2cloud.php?weblob_id=foo/42
        // $matches[1] - single or double quote, or paren
        // $matches[2] - the weblob_id, e.g. foo/42
        // $matches[3] - single or double quote, or paren

        $weblob_url = $this->get_url_from_weblob_id($matches[2]);
        return $weblob_url ? $matches[1] . $weblob_url . $matches[3] : $matches[0];
    }

    //--------
    // Gets the direct cloud storage URL for the media content when rendering them.
    function ob_callback(&$buffer)
    {
        // The URL can be in
        //  - single quotes: '...wp2cloud.php?weblob_id=foo/42'
        //  - double quotes: "...wp2cloud.php?weblob_id=foo/42"
        //  - parentheses:   (...wp2cloud.php?weblob_id=foo/42)

        return preg_replace_callback( '#(["\'\\(])[^"\'\\)>]+/wp2cloud.php\?weblob_id=([^"\'\\)>]+)(["\'\\)>])#', array(&$this, 'xlate_wbid_url'), $buffer);
    }

    //--------
    // The edit attachment functionality cannot handle redirect, so we
    // translate the URL here.
    function load_image_to_edit_attachmenturl($url, $postID, $size) {

        return $this->wbid_url_to_cloud($url);
    }

    //--------
    // Processes and extracts Exif tags.
    function process_file ($postID, $file_path) {
        $size = getimagesize($file_path, $info);
        $keywords = array();

        if (isset($info["APP13"])) {
            $iptc = iptcparse($info["APP13"]);
            {
                if (is_array($iptc)) {
                $keywords = isset($iptc["2#025"]) ? $iptc["2#025"] : array();
                }
            }
        }

        if (!function_exists('exif_read_data'))
            return;

        $ifd0 = @exif_read_data($file_path, 'IFD0');

        if($ifd0 == true) {
            $make = isset($ifd0['Make']) ? $ifd0['Make'] : "";
            $model = isset($ifd0['Model']) ? $ifd0['Model'] : "";
            $dateString = $ifd0['DateTimeDigitized'];

            if(!isset($keywords)) {
                $keywords = isset($ifd0['Keywords']) ? $ifd0['Keywords'] : "";
                $keywords = explode(";", $keywords);
            }

            $exif = exif_read_data($file_path, 'EXIF');

            $exposuretime = isset($exif['ExposureTime']) ? $exif['ExposureTime'] : 0;
            $fnumber = isset($exif['FNumber']) ? $exif['FNumber'] : 0;
            $iso = isset($exif['ISOSpeedRatings']) ? $exif['ISOSpeedRatings'] : 0;

             $date = new DateTime($dateString);
        }

        $this->set_media_tags_for_item($postID, $keywords);
    }

    //--------
    // Adds the passed array of keywords to the object.
    function set_media_tags_for_item(
        $media_item_id,
        $tags_tmp_array) {

        if (!defined('MEDIA_TAGS_TAXONOMY'))
            return;

        $select_media_tags = array();

        if ($tags_tmp_array &&
            count($tags_tmp_array) > 0){
            foreach($tags_tmp_array as $idx => $tag_val) {
                if($tag_val == "") {
                    continue;
                }
                $tag_slug = sanitize_title_with_dashes($tag_val);

                if (!($id = term_exists($tag_slug, MEDIA_TAGS_TAXONOMY))) {
                    $inserted_term_id = wp_insert_term($tag_val, MEDIA_TAGS_TAXONOMY, array('slug' => $tag_slug));
                    if (is_wp_error($inserted_term_id))
                        continue;
                    if (isset($inserted_term_id['term_id']))
                        $select_media_tags[] = $inserted_term_id['term_id'];
                }
                else
                    $select_media_tags[] = $id['term_id'];
            }
        }

        if (count($select_media_tags))
        {
            $selected_media_tag_terms = array();

            foreach($select_media_tags as $media_tag_id) {
                $selected_media_tag_terms[] = get_term($media_tag_id, MEDIA_TAGS_TAXONOMY);
            }
            //--------
            // Add the tags to the object.
            $media_tag_slugs = array();
            $media_item_terms_current = wp_get_object_terms($media_item_id, MEDIA_TAGS_TAXONOMY);

            if (!$media_item_terms_current) {
                if ($selected_media_tag_terms) {
                    foreach($selected_media_tag_terms as $selected_media_tag_term)
                        $media_tag_slugs[$selected_media_tag_term->slug] = $selected_media_tag_term->slug;
                }
            }
            else {
                //--------
                // We need to combine the media-tag items already defined the new ones.
                foreach($media_item_terms_current as $idx => $current_term)
                    $media_tag_slugs[$current_term->slug] = $current_term->slug;

                foreach($selected_media_tag_terms as $selected_media_tag_term)
                    $media_tag_slugs[$selected_media_tag_term->slug] = $selected_media_tag_term->slug;
            }

            if (count($media_tag_slugs)) {
                // If the Media Item does not have any assigned Media-Tag we simple assign the selected Media-Tags
                wp_set_object_terms($media_item_id, $media_tag_slugs, MEDIA_TAGS_TAXONOMY);
            }
        }
    }

    //--------
    // Uploads the file content into the ClouSE WEBLOB.
    function upload_image_to_cloud($imagePath, $imageId) {
        $wbid = $this->parse_weblob_id($imageId);
        $weblob_id = $this->fmt_weblob_id($wbid['id'], $wbid['name']);

        //--------
        // Don't fail if there is no file: it either has been already
        // moved to the cloud or it's truly missing, in which case
        // we replicate the missing state.
        if (!file_exists($imagePath))
            return $weblob_id;

        try {
            $fp = fopen($imagePath, "r");

            if (!$fp) {
                throw new Exception('Couldnt open file: ' . $imagePath);
            }

            //--------
            // To make it scalable, we upload file in chunks into the WEBLOB.
            $total_size = filesize($imagePath);
            $size = 0;
            $chunk_len = 1024 * 128;

            //--------
            // Start upload.  The value$wblob_info field contains 2 control
            // commands:
            //
            //   name:foo-bar.jpg
            //   streaming:first
            //
            // The "name" control command specifies the custom file name for
            // the WEBLOB URL.
            //
            // The "streaming" control command specifies that this is the first
            // chunk of the content.  In this case the first chunk is empty.
            // Further chunks are uploaded below via corresponding update
            // statements.
            //
            // We use 'replace into ...' here because uniqueness of user
            // initiated uploads is guaranteed by wp_handle_upload and
            // sometimes WordPress generates duplicate images.

            $this->query('replace into # (id, name, value$wblob_info, value$wblob) values (#, "#", "name:#;streaming:first", NULL)',
                array($this->ClouSE_table_name, $wbid['id'], $wbid['name'], preg_replace("/[^\w\.-]+/", "_", $wbid['name'])));

            //--------
            // Upload the full content in chunks of $chunk_len.
            while ($data = fread($fp, $chunk_len)) {
                $size += strlen($data);

                //--------
                // Append the next / last chunk.  The value$wblob_info field
                // contains the 'streaming:next' or 'streaming:last' control
                // command; the value$wblob contains a chunk of content.
                $action = $size == $total_size ? 'last' : 'next';

                $this->query('update # set value$wblob_info = "streaming:#", value$wblob = "#" where id = # and name = "#"',
                    array($this->ClouSE_table_name, $action, $data, $wbid['id'], $wbid['name']));

            }
        }
        catch(Exception $e) {
            throw $e;
        }

        return $weblob_id;
    }

    function image_downsize($ff, $id, $size = 'medium') {
        $id = (int) $id;
        if (!$post =& get_post($id)) {
            return false;
        }
        $id = $post->ID;

        $file = get_attached_file($id, true);

        //-------
        // Only deal with attachments uploaded by us.
        if (strpos($file, '$wblob') === false)
            return false;

        $img_url = null;
        $meta = wp_get_attachment_metadata($id);
        $width = $height = 0;
        $is_intermediate = false;
        $file_basename = wp_basename($file);

        // try for a new style intermediate size
        if ($intermediate = image_get_intermediate_size($id, $size)) {
            $img_file = str_replace($file_basename, $intermediate['file'], $file);
            $img_url = $this->wp_get_attachment_url($img_file, $id);
            $width = $intermediate['width'];
            $height = $intermediate['height'];
            $is_intermediate = true;
        }
        elseif ($size == 'thumbnail') {
            // fall back to the old thumbnail
            if (($thumb_file = wp_get_attachment_thumb_file($id)) && $info = getimagesize($thumb_file)) {
                $img_file = str_replace($file_basename, wp_basename($thumb_file), $file);
                $img_url = $this->wp_get_attachment_url($img_file, $id);
                $width = $info[0];
                $height = $info[1];
                $is_intermediate = true;
            }
        }

        if (!$img_url)
            $img_url = $this->wp_get_attachment_url($file, $id);

        if (!$width && !$height && isset($meta['width'], $meta['height'])) {
            // any other type: use the real image
            $width = $meta['width'];
            $height = $meta['height'];
        }

        if ($img_url) {
            // we have the actual image size, but might need to further constrain it if content_width is narrower
            list( $width, $height ) = image_constrain_size_for_editor( $width, $height, $size );
            return array( $img_url, $width, $height, $is_intermediate );
        }

        return false;
    }

    function maybe_get_cdn_url($img_url) {
        //-------
        // Hook up CDN.
        if ($img_url && ($options = get_option('wp2cloud')) && $options['cdn'])
        {
            // The $img_url format is the following:
            // [scheme]://[host]/[bucket]/[path]
            // we need to substitute scheme, host and bucket with
            // the CDN URL.
            $wp2cloud_cdn = $options['cdn'];
            if (strpos($wp2cloud_cdn, '://') === false)
                $wp2cloud_cdn = (empty($_SERVER['HTTPS']) ? 'http://' : 'https://') . $wp2cloud_cdn;

            $wp2cloud_url_arr = parse_url($wp2cloud_cdn);
            $img_url_arr = parse_url($img_url);

            if ($wp2cloud_url_arr !== false && $img_url_arr !== false)
            {
                $img_rel_path = substr($img_url_arr['path'], 1);
                $img_sub_path = substr($img_rel_path, strpos($img_rel_path, '/'));

                $wp2cloud_port = isset($wp2cloud_url_arr['port']) ? ':'.$wp2cloud_url_arr['port'] : '';
                $wp2cloud_path = isset($wp2cloud_url_arr['path']) ? $wp2cloud_url_arr['path'] : '';

                $img_url = ($wp2cloud_url_arr['scheme'] == 'http' ? 'http' : 'https').'://'.
                    $wp2cloud_url_arr['host'].
                    $wp2cloud_port.
                    $wp2cloud_path.
                    $img_sub_path;
            }
        }

        return $img_url;
    }

    function get_url_from_weblob_id($weblob_id) {
        $img_url = "";

        //--------
        // Due to multiple levels of abstraction, it may happen that
        // the same Weblob URL gets retrieved multiple times in a row
        // so we try to avoid unnecessary DB access.
        if ($this->last_wbid === $weblob_id)
            return $this->last_wb_url;

        try {
            //-------
            // Get the cloud URL for the ID.  The value$wblob_info returns
            // the cloud storage URL that can be used by the web browser to
            // download the picture (or other media) directly from the
            // cloud storage.
            $wbid = $this->parse_weblob_id($weblob_id);
            $result = $this->query('select convert(value$wblob_info, char(1024)) from # where id=# and name="#"',
                array($this->ClouSE_table_name, $wbid['id'], $wbid['name']));

            if(count($result))
                $img_url = $this->maybe_get_cdn_url($result[0][0]);

        }
        catch(Exception $e) {
        }

        $this->last_wbid = $weblob_id;
        $this->last_wb_url = $img_url;

        return $img_url;
    }

    //--------
    // BuddyPress support.  BuddyPress stores avatars on the local file
    // system directly, bypassing the WordPress media library mechanism.
    // Thus, it needs a different storage mechanism and a different
    // storage strategy that works around the avatars-are-local-files
    // assumptions.
    function ensure_bp_avatars_table() {
        try {
            //--------
            // Create the table that stores BuddyPress avatars as WEBLOBs.
            // BuddyPress avatars are keyed by avatar dir (e.g. 'avatars')
            // and item id.  Each avatar has 2 images: full and thumb,
            // represented by 0 and 1 value in the type field.

            // A WEBLOB field is expressed via two MySQL fields:
            //   value$wblob_info blob -- control commands on input / URL on output
            //   value$wblob  longblob -- BLOB to store the media content

            $this->query('set sql_mode="NO_ENGINE_SUBSTITUTION"');
            $this->query('create table if not exists # (
                dir varchar(128) collate latin1_bin, id bigint, type tinyint,
                value$wblob_info blob, value$wblob longblob,
                primary key(dir, id, type)) engine = "ClouSE"',
                array($this->bp_avatars_table));
        } catch (Exception $e) {
            // Ignore the error.  We let the caller retry and show real error.
        }
    }

    //--------
    // Runs query, and tries to create BuddyPress avatars table on failure.
    function bp_query($sqlQuery, $params) {
        $retry = true;

        while(true) {
            try {
                $result = $this->query($sqlQuery, $params);
            }
            catch(Exception $e) {
                // Maybe we just don't have the table yet?
                if ($retry) {
                    $retry = false;
                    $this->ensure_bp_avatars_table();
                    continue;
                }

                throw $e;
            }

            break;
        }

        return $result;
    }

    //--------
    // Get the cloud URLs for the BuddyPress: full and thumb.
    function get_bp_avatar_cloud_urls($avatar_dir, $item_id) {
        $results = $this->bp_query('select convert(value$wblob_info, char(1024)) from # where dir="#" and id=# order by type',
            array($this->bp_avatars_table, $avatar_dir, intval($item_id)));

        if (!count($results))
            return null;

        //--------
        // The table is keyed by dir, id and type with type=0 expressing full
        // and type=1 expressing thumb.  So the results are ordered as
        // {full, thumb}.
        return array('full' => $results[0][0], 'thumb' => $results[1][0]);
    }

    //--------
    // Upload one BuddyPress avatar image into the cloud: full OR thumb.
    function upload_bp_avatar_file($avatar_dir, $item_id, $type, $imagePath) {
        $fp = fopen($imagePath, "r");

        if (!$fp) {
            throw new Exception('Couldnt open file: ' . $imagePath);
        }

        //--------
        // To make it scalable, we upload file in chunks into the WEBLOB.
        $total_size = filesize($imagePath);
        $size = 0;
        $chunk_len = 1024 * 128;

        $this->bp_query('replace into # (dir, id, type, value$wblob_info, value$wblob) values ("#", #, #, "name:avatar.jpg;streaming:first", NULL)',
            array($this->bp_avatars_table, $avatar_dir, intval($item_id), intval($type)));

        //--------
        // Upload the full content in chunks of $chunk_len.
        while ($data = fread($fp, $chunk_len)) {
            $size += strlen($data);

            //--------
            // Append the next / last chunk.
            $action = $size == $total_size ? 'last' : 'next';

            $this->bp_query('update # set value$wblob_info = "streaming:#", value$wblob = "#" where dir = "#" and id = # and type = #',
                array($this->bp_avatars_table, $action, $data, $avatar_dir, intval($item_id), intval($type)));
        }
    }

    //--------
    // Upload BuddyPress avatar into the cloud: full and thumb.
    function upload_bp_avatar($avatar_dir, $item_id, $files) {
        //--------
        // Upload both avatar files as one transaction.
        // type=0 for full images and type=1 for thumb images.
        if (!file_exists($files['full']) || !file_exists($files['thumb']))
            return;

        try {
            $this->query('start transaction');
            $this->upload_bp_avatar_file($avatar_dir, $item_id, 0, $files['full']);
            $this->upload_bp_avatar_file($avatar_dir, $item_id, 1, $files['thumb']);
            $this->query("commit");
        } catch(Exception $e) {
            $this->query("rollback");
            throw $e;
        }
    }

    //--------
    // Delete BuddyPress avatar from the cloud.
    function delete_bp_avatar($avatar_dir, $item_id) {
        $result = $this->bp_query('delete from # where dir="#" and id=#',
            array($this->bp_avatars_table, $avatar_dir, intval($item_id)));
    }

    //--------
    // Get fake avatar folder for the filters below.
    // $val must be 'basedir' or 'baseurl'.
    function get_fake_avatar_folder($val) {
        $uploads = wp_upload_dir();

        if($uploads['error'] !== false)
            return false;

        //--------
        // Sometimes, BuddyPress overrides the standard basedir value and
        // there seems to be no way to get the original value.  So we try
        // to undo what BuddyPress does and recover the orginal base value.
        $base = $uploads[$val];
        $sub = $uploads['subdir'];

        $suf_start = strlen($base) - strlen($sub);

        if(strrpos($base, $sub) === $suf_start)
            $base = substr($base, 0, $suf_start);

        return $base.'/wp2cloud/bp-avatar';
    }

    //--------
    // Point avatar folder URL to a special place.
    function bp_core_avatar_folder_url($folder_url, $item_id, $object, $avatar_dir) {
        //--------
        // This filter is called from the bp_core_fetch_avatar function and
        // that function is looking for the avatar on the file system.  The
        // function will call our filter to fix the URLs, but it first needs
        // to find the files.  Here we check if the avatar is stored in the
        // cloud and point to a special place on the file system that does
        // have some avatar files.
        $this->bp_fetch_urls = $this->get_bp_avatar_cloud_urls($avatar_dir, $item_id);

        if(!$this->bp_fetch_urls)
            return $folder_url;

        //--------
        // Generate fake avatar file names.
        $fake_avatar_dir = $this->get_fake_avatar_folder('basedir');

        if (!$fake_avatar_dir)
            return $folder_url;

        $avatar_full = $fake_avatar_dir.'/mystery-man-bpfull.jpg';
        $avatar_thumb = $fake_avatar_dir.'/mystery-man-bpthumb.jpg';

        //--------
        // Copy the files from the plugin to the fake avatar dir.
        // We try 5 times in case we hit an intermittent error due
        // to multiple treads trying to do this concurrently.
        $src_dir = dirname(__FILE__).'/bp-avatar';

        for($tries = 5; $tries--; ) {
            if(!file_exists($avatar_full)) {
                wp_mkdir_p($fake_avatar_dir);

                if(!copy($src_dir.'/mystery-man-bpfull.jpg',$avatar_full))
                    continue;
            }

            if(!file_exists($avatar_thumb)) {
                wp_mkdir_p($fake_avatar_dir);

                if(!copy($src_dir.'/mystery-man-bpthumb.jpg',$avatar_thumb))
                    continue;
            }

            //--------
            // Success!
            $fake_avatar_url = $this->get_fake_avatar_folder('baseurl');
            return $fake_avatar_url ? $fake_avatar_url : $folder_url;
        }

        //--------
        // We tried several times and failed.
        return $folder_url;
    }

    //--------
    // Point avatar folder dir to a special place.
    function bp_core_avatar_folder_dir($folder_dir, $item_id, $object, $avatar_dir ) {
        if(!$this->bp_fetch_urls) {
            //--------
            // Here we could be called from the bp_core_delete_existing_avatar
            // function and it needs the dir to exist in order to call our
            // bp_core_delete_existing_avatar filter.  So we create the dir
            // (so that it can delete it).
            wp_mkdir_p($folder_dir);
            return $folder_dir;
        }

        //--------
        // This filter is called from the bp_core_fetch_avatar function
        // and the avatar is stored in the cloud.  Point to a special place
        // on the file system that has avatar files.
        $fake_avatar_dir = $this->get_fake_avatar_folder('basedir');
        return $fake_avatar_dir ? $fake_avatar_dir : $folder_dir;
    }

    //--------
    // Get the appropriate avatar URL, if any.
    function get_avatar_url($val) {
        if(!$this->bp_fetch_urls)
            return null;

        $urls = $this->bp_fetch_urls;
        $this->bp_fetch_urls = null;

        if(strpos($val, '-bpfull.') !== false)
            $url = $urls['full'];
        else
            $url = $urls['thumb'];

        return $this->maybe_get_cdn_url($url);
    }

    //--------
    // Translate avatar image HTML into a WEBLOB URL.
    function bp_core_fetch_avatar($html, $params, $item_id, $avatar_dir, $css_id, $html_width, $html_height, $avatar_folder_url, $avatar_folder_dir) {
        $url = $this->get_avatar_url($html);

        if(!$url)
            return $html;

        //--------
        // Replace the image URL with a WEBLOB URL.
        return preg_replace('/<img src="[^"]*"/', '<img src="'.$url.'"', $html);
    }

    //--------
    // Translate avatar image URL into a WEBLOB URL.
    function bp_core_fetch_avatar_url($avatar_url) {
        $url = $this->get_avatar_url($avatar_url);
        return $url ? $url : $avatar_url;
    }

    //--------
    // Detect BuddyPress upload.
    function bp_core_pre_avatar_handle_upload($default, $file, $upload_dir_filter) {
        //--------
        // BuddyPress doesn't go thru the media library, so when it uploads
        // the image (which is temporary image for cropping), it becomes
        // orphan.  We dected this case and just don't upload the image.
        $this->bp_uploading_avatar = true;
        return $default;
    }

    //--------
    // Crop and upload BuddyPress avatar.  BuddyPress does not have
    // a convenient point of customization that we could use to upload
    // the images, so we override the whole bp_core_avatar_handle_crop
    // function.  Most of the code is merely a copy of the original
    // BuddyPress function.
    function crop_and_upload_bp_avatar($r) {
        // ### START COPY FROM bp_core_avatar_handle_crop

        extract( $r, EXTR_SKIP );

        if ( !$original_file )
            return false;

        $original_file = bp_core_avatar_upload_path() . $original_file;

        if ( !file_exists( $original_file ) )
            return false;

        if ( !$item_id )
            $avatar_folder_dir = apply_filters( 'bp_core_avatar_folder_dir', dirname( $original_file ), $item_id, $object, $avatar_dir );
        else
            $avatar_folder_dir = apply_filters( 'bp_core_avatar_folder_dir', bp_core_avatar_upload_path() . '/' . $avatar_dir . '/' . $item_id, $item_id, $object, $avatar_dir );

        if ( !file_exists( $avatar_folder_dir ) )
            return false;

        // Delete the existing avatar files for the object
        bp_core_delete_existing_avatar( array( 'object' => $object, 'avatar_path' => $avatar_folder_dir ) );

        // Make sure we at least have a width and height for cropping
        if ( !(int) $crop_w )
            $crop_w = bp_core_avatar_full_width();

        if ( !(int) $crop_h )
            $crop_h = bp_core_avatar_full_height();

        // Set the full and thumb filenames
        $full_filename  = wp_hash( $original_file . time() ) . '-bpfull.jpg';
        $thumb_filename = wp_hash( $original_file . time() ) . '-bpthumb.jpg';

        // Crop the image
        $full_cropped  = wp_crop_image( $original_file, (int) $crop_x, (int) $crop_y, (int) $crop_w, (int) $crop_h, bp_core_avatar_full_width(), bp_core_avatar_full_height(), false, $avatar_folder_dir . '/' . $full_filename );
        $thumb_cropped = wp_crop_image( $original_file, (int) $crop_x, (int) $crop_y, (int) $crop_w, (int) $crop_h, bp_core_avatar_thumb_width(), bp_core_avatar_thumb_height(), false, $avatar_folder_dir . '/' . $thumb_filename );

        // Check for errors
        if ( ! $full_cropped || ! $thumb_cropped || is_wp_error( $full_cropped ) || is_wp_error( $thumb_cropped ) )
            return false;

        // Remove the original
        @unlink( $original_file );

        // ### END COPY FROM bp_core_avatar_handle_crop

        //--------
        // Now upload the images to the cloud.
        // $avatar_dir and $item_id are expanded from $r
        $this->upload_bp_avatar($avatar_dir, $item_id, array('full' => $full_cropped, 'thumb' => $thumb_cropped));

        @unlink($full_cropped);
        @unlink($thumb_cropped);

        return true;
    }

    //--------
    // Handle BuddyPress avatar upload.
    function bp_core_pre_avatar_handle_crop($default, $r) {
        //--------
        // We must return false on success and true if we want BuddyPress
        // to continue, so we don't really have a way to communicate
        // failure.  So to fake it, we delete to orginal file and
        // let BuddyPress continue and fail due to file missing.

        if(!$this->crop_and_upload_bp_avatar($r)) {
            if(!$r['original_file'])
                return true;

            @unlink(bp_core_avatar_upload_path() . $r['original_file']);
            return true;
        }

        return false;  // false means we've successfully completed the operation
    }

    function bp_core_delete_existing_avatar($args) {
        //--------
        // The avatar_dir / item_id discovery code is copied from
        // the BuddyPres' bp_core_delete_existing_avatar function.

        global $bp;

        $defaults = array(
            'item_id'    => false,
            'object'     => 'user', // user OR group OR blog OR custom type (if you use filters)
            'avatar_dir' => false
        );

        $args = wp_parse_args( $args, $defaults );
        extract( $args, EXTR_SKIP );

        if ( empty( $item_id ) ) {
            if ( 'user' == $object )
                $item_id = bp_displayed_user_id();
            else if ( 'group' == $object )
                $item_id = $bp->groups->current_group->id;
            else if ( 'blog' == $object )
                $item_id = $current_blog->id;

            $item_id = apply_filters( 'bp_core_avatar_item_id', $item_id, $object );

            if ( !$item_id ) return;
        }

        if ( empty( $avatar_dir ) ) {
            if ( 'user' == $object )
                $avatar_dir = 'avatars';
            else if ( 'group' == $object )
                $avatar_dir = 'group-avatars';
            else if ( 'blog' == $object )
                $avatar_dir = 'blog-avatars';

            $avatar_dir = apply_filters( 'bp_core_avatar_dir', $avatar_dir, $object );

            if ( !$avatar_dir ) return;
        }

        //--------
        // Delete the avatar from the cloud.
        $this->delete_bp_avatar($avatar_dir, $item_id);
    }
}

//--------
// Check if this script is called explicitly to get a Weblob URL via
// the Weblob ID.  This method is used in the places that need a
// weblob_id-based URL (e.g. in the tinyMCE editor).
if(strpos($_SERVER['PHP_SELF'], basename(__FILE__)) !== false && !empty($_GET['weblob_id']))
{
    $weblob_id = $_GET['weblob_id'];

    //--------
    // WordPress may add image resize query on top of the weblob_id-based
    // URL, so the full URL could look like this:
    //
    //   wp2cloud.php?weblob_id=42/foo.jpg?w=128&h=128
    //
    // In that case the weblob_id is going to look like 42/foo.jpg?w=128
    // so we need to remove the extra query part.

    if(($qp = strpos($weblob_id, '?')) !== false)
        $weblob_id = substr($weblob_id, 0, $qp);

    $img_url = $wp2cloud_plugin->get_url_from_weblob_id($weblob_id);

    if($img_url) {
        //--------
        // We should never update WEBLOBs, so we cache for 365 days.
        header('Cache-Control: public, max-age=31536000');
    } else {
        //--------
        // The file is missing in the cloud, but it could be a temp
        // file that WordPress doesn't create an attachment for (apparently
        // WordPress does this with midsize-foo image when it uploads
        // custom header image).
        $uploads = wp_upload_dir();

        if($uploads['error'] === false)
            $img_url = $uploads['baseurl'] . '/$wblob/' . $weblob_id;
    }

    if($img_url)
        header('Location: ' . $img_url, true, 301);  // redirect
}

?>
